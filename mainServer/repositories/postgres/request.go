package postgres

import (
	"database/sql"
	"mainServer/entities"
	"mainServer/models"
)

type PgRequestRepository struct {
	Db *sql.DB
}

// NewPgRequestRepository creates a new repository and tables in the database, if necessary.
func NewPgRequestRepository(db *sql.DB) PgRequestRepository {
	repo := PgRequestRepository{Db: db}
	err := repo.createRequestTable()
	if err != nil {
		panic(err)
	}
	return repo
}

func (r PgRequestRepository) CreateRequest(req entities.Request) (entities.Request, error) {

	// store request entity
	stmt, err := r.Db.Prepare("INSERT INTO request (articleID, sourceVersionID, sourceHistoryID, targetVersionID, targetHistoryID, conflicted) VALUES ($1,$2,$3,$4,$5,$6) RETURNING id,status")
	if err != nil {
		return entities.Request{}, err
	}
	row := stmt.QueryRow(req.ArticleID, req.SourceVersionID, req.SourceHistoryID, req.TargetVersionID, req.TargetHistoryID, req.Conflicted)

	// Retrieve columns generated by database
	var id int64
	var state string
	err = row.Scan(&id, &state)
	if err != nil {
		return entities.Request{}, err
	}

	req.RequestID = id
	req.Status = state
	return req, nil
}

func (r PgRequestRepository) UpdateRequest(req entities.Request) error {

	// update all fields of request entity by id
	stmt, err := r.Db.Prepare("UPDATE request SET articleID=$2, sourceVersionID=$3, sourceHistoryID=$4, targetVersionID=$5, targetHistoryID=$6, status=$7, conflicted=$8 WHERE id=$1")
	if err != nil {
		return err
	}

	// TODO: check if rows were affected, and return error if not
	_, err = stmt.Exec(req.RequestID, req.ArticleID, req.SourceVersionID, req.SourceHistoryID, req.TargetVersionID, req.TargetHistoryID, req.Status, req.Conflicted)
	if err != nil {
		return err
	}
	return nil
}

func (r PgRequestRepository) SetStatus(request int64, status string) error {

	// store request entity
	stmt, err := r.Db.Prepare("UPDATE request SET status = $2 WHERE id = $1")
	if err != nil {
		return err
	}
	_, err = stmt.Exec(request, status)
	if err != nil {
		return err
	}
	return nil
}

func (r PgRequestRepository) GetRequest(request int64) (entities.Request, error) {
	// store request entity
	stmt, err := r.Db.Prepare("SELECT * FROM request WHERE id=$1")
	if err != nil {
		return entities.Request{}, err
	}
	row := stmt.QueryRow(request)

	// Retrieve columns generated by database
	var req entities.Request
	err = row.Scan(&req.RequestID, &req.ArticleID, &req.SourceVersionID, &req.SourceHistoryID, &req.TargetVersionID, &req.TargetHistoryID, &req.Status, &req.Conflicted)
	if err != nil {
		return entities.Request{}, err
	}

	return req, nil
}

func (r PgRequestRepository) GetRequestList(articleId int64, sourceId int64, targetId int64, relatedId int64) ([]models.Request, error) {
	stmt, err := r.Db.Prepare(`SELECT * FROM request WHERE articleID=$1 AND (sourceversionid IN ($2, $4)
    OR targetversionid IN ($3, $4) OR $5)`)

	if err != nil {
		return nil, err
	}

	var list []models.Request
	var rows *sql.Rows

	// Query all rows if no filters have been provided
	if sourceId == -1 && targetId == -1 && relatedId == -1 {
		rows, err = stmt.Query(articleId, sourceId, targetId, relatedId, true)
	} else {
		rows, err = stmt.Query(articleId, sourceId, targetId, relatedId, false)
	}

	if err != nil {
		return nil, err
	}

	for rows.Next() {
		var request models.Request
		err = rows.Scan(&request.RequestID, &request.ArticleID, &request.SourceVersionID, &request.SourceHistoryID, &request.TargetVersionID, &request.TargetHistoryID, &request.Status, &request.Conflicted)
		list = append(list, request)
	}
	return list, nil
}

// creates request table, storing history/commit IDs as fixed-length,
// as they are always sha-1 hashes of 40 hex digits long
func (r PgRequestRepository) createRequestTable() error {
	_, err := r.Db.Exec(`CREATE TABLE IF NOT EXISTS request (
    	id SERIAL PRIMARY KEY,
    	articleID INT NOT NULL,
    	sourceVersionID INT NOT NULL,
    	sourceHistoryID NCHAR(40),
    	targetVersionID INT NOT NULL,
    	targetHistoryID NCHAR(40),
    	status VARCHAR(16) NOT NULL DEFAULT 'pending',
    	conflicted BOOLEAN NOT NULL,
        FOREIGN KEY (articleID) REFERENCES article(id),
        FOREIGN KEY (sourceVersionID) REFERENCES version(id),
        FOREIGN KEY (targetVersionID) REFERENCES version(id)
    )`)
	return err
}
